Замыкание — это функции, которые **запоминают и используют переменные из внешней области видимости** даже после завершения выполнения этой области.

В Go можно объявлять **анонимные функции** и присваивать их переменной. Если такая функция использует переменные из внешней функции, она **создаёт замыкание**, сохраняя доступ к этим переменным.

**Пример:**

```go
func main() {  
    a1 := foo()
    a2 := foo()
    fmt.Println(a1())  // 1
    fmt.Println(a1())  // 2
    fmt.Println(a2())  // 1
    fmt.Println(a2())  // 2
}  
  
func foo() func() int {  
    x := 0  
    return func() int {  
       x++  
       return x  
    }  
}
```

В данном примере используя **escape analysis** Go каждый раз перемещает `x` со стека на кучу.
При каждом новом вызове foo() на куче создается новая переменная `x`.

**\*Замыкания захватывают переменные по ссылке а не копируют их**

Вот несколько примеров:

```go
funcs := []func(){}

for i := 0; i < 3; i++ {
	funcs = append(funcs, func() { fmt.Print(i) })
}

for _, f := range funcs {
	f()
}

```

так происходит потому что замыкания захватили ссылку на `i` и к моменту их вызова `i = 3`, однако с версии 1.22 на внутри скоупа оператора создается новая локальная переменная i благодаря чему вывод будет 0 1 2.

Для того чтобы исправить можно передавать `i` в качестве аргумента в анонимную функцию или создать копию `i`:

```go
funcs := []func(){}

for i := 0; i < 3; i++ {
	i := i
	funcs = append(funcs, func() { fmt.Print(i) })
}

for _, f := range funcs {
	f()
}

// Вывод
// 0 1 2
```

В Go можно объявлять переменную с тем же именем в более узком scope 

**Пример через defer**

```go
i := 1  
  
defer func() {  
    fmt.Println(i, "first defer")  
}()  
defer fmt.Println(i, "first print")  
  
i = 2  
  
defer func() {  
    fmt.Println(i, "second defer")  
}()  
defer fmt.Println(i, "second print")

// Вывод
2 second print
2 second defer
1 first print
2 first defer
```

Так получается потому что в `fmt.Print()` мы подаем копию