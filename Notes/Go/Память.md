### Stack

По идеи все переменные созданные не через make или new выделяются на стэке, на самом деле не всегда

Рассмотрим такую проблему:

```go
func main() {
	x := getValue()
	Println(*x)
}

func getValue() *int {
	x := 4
	return &x
}
```

Вызов функции Println затрет stack frame с x и мы получим проблему **Dangling Pointer**
В Go такая проблема решается путем выделения x на heap, для определения где выделить переменную в go существует алгоритм **Escape Analysis**

### Escape Analysis

**Escape Analysis** — это процесс, который **Go Compiler** использует, чтобы определить, должна ли переменная храниться в **стеке (stack)** или **куче (heap)**.

Если переменная **"уходит" за пределы функции**, она **уходит в кучу (escapes to heap)**. В противном случае она остаётся в **стеке**, где её удаление дешевле и быстрее.

##### Основные правила:

1. **Если переменная используется только внутри функции**, она остается в стеке.
    
2. **Если переменная "убегает" из функции** (например, возвращается из функции по указателю, передается в замыкание или сохраняется в глобальной переменной), она перемещается в кучу.


---

### Инициализация значений по умолчанию:

Если переменная объявлена без явного значения, Go автоматически присвоит ей **нулевое значение** (zero value) в соответствии с её типом:

- **Числовые типы (int, float64 и т. д.)** → `0` (или `0.0` для float)
- **Булевый тип (bool)** → `false`
- **Строки (string)** → `""` (пустая строка)
- **Срезы, карты, каналы, интерфейсы, функции, указатели** → `nil`
- **Структуры** → все поля структуры будут инициализированы нулевыми значениями их типов



