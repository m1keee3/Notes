
### Виртуальная память

Это технология управления памятью, используемая ОС для предоставления программам иллюзии наличия большого, непрерывного адресного пространства, даже если физическая память (RAM) ограничена. Виртуальная память также обеспечивает изоляцию процессов, защиту памяти и эффективное использование ресурсов.

### Основные концепции виртуальной памяти

1. **Адресное пространство**:
    
    - Каждая программа работает в своем собственном **виртуальном адресном пространстве**, которое не зависит от других программ и физической памяти.
        
    - Виртуальные адреса преобразуются в физические адреса с помощью аппаратной поддержки (MMU — Memory Management Unit).
        
2. **Страницы (Pages)**:
    
    - Виртуальная память делится на блоки фиксированного размера, называемые **страницами** (обычно 4 КБ на x86/x64 архитектурах).
        
    - Физическая память также делится на страницы того же размера.
        
3. **Таблица страниц (Page Table)**:
    
    - Таблица страниц — это структура данных, которая хранит соответствие между виртуальными и физическими адресами.
        
    - Каждая запись в таблице страниц (Page Table Entry, PTE) содержит информацию о том, где находится соответствующая страница в физической памяти или на диске.
        
4. **Подкачка (Swapping)**:
    
    - Если физической памяти не хватает, операционная система может переместить неиспользуемые страницы на диск (в **файл подкачки** или **swap-раздел**) и освободить физическую память для других задач.
        
    - Когда программа пытается получить доступ к странице, которая находится на диске, происходит **page fault** (ошибка страницы), и операционная система загружает страницу обратно в память.
        
5. **Фрагментация**:
    
    - Виртуальная память позволяет программам использовать непрерывное адресное пространство, даже если физическая память фрагментирована.


---

### Stack

По идеи все переменные созданные не через make или new выделяются на стэке, на самом деле не всегда

Рассмотри такую проблему:

```go
func main() {
	x := getValue()
	Println(*x)
}

func getValue() *int {
	x := 4
	return &x
}
```

Вызов функции Println затрет stack frame с x и мы получим проблему **Dangling Pointer**
В Go такая проблема решается путем выделения x на heap

Переменная будет выделена на heap а не на stack если:
1. Результат возвращается по ссылке
2. Значение передается в аргумент типа interface{}
3. Размер значения переменной превышает лимиты стека

### Heap


---

### Инициализируются значением по умолчанию:

Если переменная объявлена без явного значения, Go автоматически присвоит ей **нулевое значение** (zero value) в соответствии с её типом:

- **Числовые типы (int, float64 и т. д.)** → `0` (или `0.0` для float)
- **Булевый тип (bool)** → `false`
- **Строки (string)** → `""` (пустая строка)
- **Срезы, карты, каналы, интерфейсы, функции, указатели** → `nil`
- **Структуры** → все поля структуры будут инициализированы нулевыми значениями их типов


---

### Escape Analysis

**Escape Analysis** — это процесс, который **Go Compiler** использует, чтобы определить, должна ли переменная храниться в **стеке (stack)** или **куче (heap)**.

Если переменная **"уходит" за пределы функции**, она **уходит в кучу (escapes to heap)**. В противном случае она остаётся в **стеке**, где её удаление дешевле и быстрее.

##### Основные правила:

1. **Если переменная используется только внутри функции**, она остается в стеке.
    
2. **Если переменная "убегает" из функции** (например, возвращается из функции по указателю, передается в замыкание или сохраняется в глобальной переменной), она перемещается в кучу.
### Фрагментация
### GC (garbage collector)

Использует алгоритм **mark & sweep**


**Пример когда старый массив не будет собран GC так как на него ссылается переменная:**

```go
arr := make([]int, 5)  
p := &arr[0]
arr = append(arr, 1)  
fmt.Println(*p)
```
