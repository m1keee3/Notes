##### Инициализация
```go
1. m := map[string]int{}
2. m := make(map[string]int, n) // n - число элементов
```

Как не надо: 

```go
var m map[int]int  // Объявляем, но не инициализируем map
m[12] = 3          // Попытка записи в nil map
fmt.Println(m)

// panic: assignment to entry in nil map
```
#### Что из себя представляет map

Операции выполняются за O(1) благодаря хэшированию

Как выглядит map header:

```go
type hmap struct {
    count      int    // количество элементов
    B          uint8  // log2(количество бакетов)
    buckets    unsafe.Pointer // указатель на массив бакетов
    oldbuckets usafe.Pointer // указатель на старый массив бакетов
    extra      *mapextra // overflow-данные
    hash       uint32 // seed для крипто устойчивости мапы
}
```

Map не использует `generics` или `interface{}`, а использует `unsafe.Poiner` (указатель на любой тип данных)
Для того чтобы понимать с каким типом мы работаем используется `type discriptor`

#### Что может быть ключом map?

Ключом map могут быть только comparable типы:
- Базовые типы
- Указатели
- Каналы и т.д.

Не могут:
- Срезы
- Функции
- Мапы

---

#### Type descriptor
Хранит всю мета информацию о типе
Предоставляет операции hash, equal, copy
```go
type _type struct {
	size uintptr
	equal func(unsafe.Pointer, unsafe.Pointer)bool
	hash func(unsafe.Pointer, uintptr)uintptr
	...
}
```

#### Map type
Хранит в себе информацию о значениях с которыми он работает (type discriptor)
```go
type mapType struct {
	key *_type
	value *_type
	...
}
```

---

#### Коллизии
Происходят когда двух разных ключей совпадает хэш

Для решения используется:
1. HOB (high order bits) (ускоренный поиск)
2. Использование overflow бакетов
3. Эвакуация данных grow()

Map в Golang использует гибридную адресацию:
- Основные данные хранятся в массиве бакетов (похоже на открытую адресацию).
- Если бакет переполняется (в нём уже 8 элементов), создаётся overflow-бакет.
- Overflow-бакеты связаны между собой (похоже на закрытую адресацию, на связные списки).


#### Хэширование

Хэш функция должна обладать следующими свойствами:

1. Равномерность
2. Быстрота (O)1
3. Детерминированность (один и тот же хеш для одинаковых ключей)
4. Крипто устойчивость (тяжело подобрать ключи таким образом что все ключи попадут в один бакет)

---

#### Buckets

Количество бакетов в map всегда степень двойки
Хранит максимум 8 элементов

```go
type bucket struct {
    tophash [8]uint8  // High order bits для ускоренного поиска
    keys    [8]K      // Ключи
    values  [8]V      // Значения
    overflow *bucket  // Указатель на следующий бакет (если переполнен)
}

tophash: [0x8F, 0x72, 0x00, 0x9A, 0x00, 0x5C, 0, 0]
```

tophash - HOB используется для быстрого поиска


#### LOB и HOB

**LOB** (low order bits) - это первые B (log от числа бакетов) биты числа 
Используются для определения индекса бакета

**HOB** (high order bits) - это 8 старших битов
Используются для быстрого поиска по бакету

Узнаем почему храниться именно log количества бакетов:

Представим что количество бакетов 8, тогда B = 3

1. Число бакетов
```
num_backets := 1 << hmap.B
```
2. Быстрое вычисление индекса бакета
```
bucket_index = hash & (num_buckets - 1)
```

num_backets = $1000_2$
hash = $101110_2$

тогда данная операция *bucket_index = hash & (num_buckets - 1)* позволит вычислить последние B битов числа:

num_backets - 1 = $0111_2$
hash & (num_buckets - 1) = $101110_2$ & $0111_2$ = $000110_2$

---

#### Поиск 

1. По LOB находит бакет 
2. Проходится по tophash (HOB)
3. Проверяет реальные значения на случай коллизий

В среднем работает за (O)1 но при большом количестве коллизий приближается к (O)n  

#### Удаление

Находит элемент по алгоритму поиска
После чего помечает его tophash нулем

```go
tophash:  [23, 67, 0, 89, 0, 102, 0, 45]  // 0 - означает удалённый элемент
keys:     [K1, K2, nil, K4, nil, K6, nil, K8]
values:   [V1, V2, nil, V4, nil, V6, nil, V8]
```
#### Расширение map (перехэширование)

Выполняется когда **loadfactor** достигает порога в 6.5 элемента на бакет
Увеличивает количество бакетов вдвое и меняет **seed** хэширования

Реализован через lazy rehashing, то есть выполняется не сразу, а постепенно с вызовом операций, для этого храниться два **unsafe.Pointers** на **buckets** и **oldbackets**

Тратит много ресурсов поэтому стоит выделять память под map:

```go
m := make(map[string]int, 1000)
```

