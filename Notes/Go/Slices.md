
**Хранит ссылку на массив, длину и размер**
##### Инициализация
```
1. list := []int
2. list := make([]int, len, cap) // Выделяет массив на куче
```

#### Структура

```
type SliceHeader struct {
    Data uintptr // Указатель на underlying массив
    Len  int     // Текущая длина
    Cap  int     // Общая емкость
}
```

`Underlaying array` - почти всегда находится на куче, кроме случаев когда срез создается из статического массива:

```
arr := [5]int{1, 2, 3, 4, 5} // Массив на стеке 
s := arr[:] // Срез ссылается на массив на стеке
```

---

#### Функция append

1. Если len < cap
   просто увеличивает длину на 1 и последний элемент заменяет на нужный
2. Если len == cap
   Аллоцирует память под новый массив с **cap x 2** если размер исходного массива < 1024 иначе увеличивает на 1/4 (но в разных версиях может быть по-разному) 
   Туда копирует значения предыдущего массива

#### Удаление из slice

```
slice := []int{1, 2, 3, 4, 5}
index := 2 // удалим элемент с индексом 2 (значение 3)

slice = append(slice[:index], slice[index+1:]...) // сдвиг элементов
fmt.Println(slice) // [1 2 4 5]
```


---

#### Места где надо быть внимательней

**Исходный массив/срез не переалоцируется** 

```
arr := [3]int{1, 2, 3}
slice := arr[:]
slice = append(slice, 4)
slice[0] = 0
fmt.Print(arr, slice) // [1 2 3] [0 1 2 3 4]
```

То есть если происходит выделение новой памяти под срез то он отвязывается от исходного массива/среза


**Задание len и cap**

```
s := make([]int, 3, 5)
fmt.Println(len(s), cap(s)) // 3 5
```

**Изменение len и cap после создания нового среза**

```
a := []int{1, 2, 3, 4, 5}
b := a[1:3]
fmt.Println(len(b), cap(b)) // 2 4
```

**Уменьшение cap через copy**

```
old := []int{1, 2, 3, 4, 5}
new := make([]int, len(old))
copy(new, old)
fmt.Println(len(new), cap(new))  // 5 5
```

**Помнить как увеличивается cap**

```
s := []int{1, 2, 3}
s = append(s, 4)
fmt.Println(len(s), cap(s))  // 4 6
```

**Срезы указывают на другие срезы**

```
a1 := make([]int, 0, 10)
a1 = append(a1, []int{1, 2, 3, 4, 5}...)
a2 := append(a1, 6)
a3 := append(a1, 7)
fmt.Println(a1, a2, a3) // [1 2 3 4 5] [1 2 3 4 5 7] [1 2 3 4 5 7]
```

**Пример Dangling pointer**

```
arr := make([]int, 5)  
p := &arr[0]  
arr = append(arr, 1)  
fmt.Println(*p)
```

В данном примере p ссылается на мертвую память

---

### Советы

- Проверять слайс на пустоту через len(list) == 0 а не list == nil
- По возможности аллоцировать память для слайса чтобы избежать лишних копирований
- Результат append присваиваем той же переменной