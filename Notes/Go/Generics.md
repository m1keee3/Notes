**Generics** — это механизм, который позволяет писать универсальный код, работающий с разными типами данных. Введены в Go 1.18.

**Без generics** приходится писать код отдельно для каждого типа или использовать `interface{}` (что не безопасно).

```go
func foo[T int | float64](a, b T) T {
	...
}

func goo[T any](a, b T) T {
	...
}
```

**\*any = interface{}**

Такая функция позволит работать с типами `int` и `float64`, однако это не слишком удобно и легче объявлять свои типы в которых будут перечислены подходящие:

```go
type Num interface {
	int | float64
}

func foo[T Num](a, b T) T {
	...
}
```

Но и это не слишком удобно, тогда мы можем использовать библиотеку `golang.org/x/exp/constrains` в которой определены некоторые типы, например `Ordered`.

Если вы используете тип на основе стандартного, то надо использовать `~`:

```go
type UserId int

func foo[T ~int | float64](a, b T) T { // без ~ не сработает
	...
}

func main() {
	a ,b := UserId(1), UserId(2)
	foo(a, b)
}
```


---

#### Generics в структурах

Используется также как и в функциях

```go
type CustomType interface {
	constrains.Ordered | []byte | []rune
}

type User[T CustomType] struct {
	Data T
}
```


---

#### Преимущество перед interface{}

1. `interface{}` вызовет панику если попытаться работать с данными неправильно.
2. Улучшенная читаемость кода.
3. Упрощение, так как `interface{}` требует дополнительных проверок и приведения типов
