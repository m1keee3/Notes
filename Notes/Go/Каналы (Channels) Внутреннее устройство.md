
`Каналы` -  это механизм для обмена данными между горутинами (легковесными потоками). Они обеспечивают безопасную синхронизацию и помогают избежать `data race`.
### Свойства

- goroutine-safe (потокобезопасность)
- Хранение элементов, семантика FIFO
- передача данных между горутинами
- блокировка горутин

#### Структура

```
type hchan struct {  
    qcount   uint           // Количество элементов в буфере  
	dataqsiz uint           // Размерность буфера  
	buf      unsafe.Pointer // Ссылка на буфер  
	
	closed   uint32         // Флаг который говорит закрыт ли канал  
	elemtype *_type         // element type  
	
	recvq    waitq          // Очередь на чтение  
	sendq    waitq          // Очередь на запись
	
	recvx    uint           // Номер ячейки в буфера для чтения
	sendx    uint           // Номер ячейки в буфере для записи
	lock mutex
}
```

**Каналы используют кольцевую очередь**, то есть когда `recvx` или `sendx` доходят до конца очереди (их значение становиться равно `cap` канала) они переходят в начало (обнуляются).

Канал захватывает мьютекс при любой операции с ним.

Тип `waitq` это очередь с ссылками на первый и последний элементы типа `sudog`, который в свою очередь хранит горутину и элемент или ссылку на ячейку, куда элемент должен быть записан, в зависимости от того стоит горутина в очередь на запись или на чтение.

**Пробуждением** канала занимается горутина которая достает/записывает значения в буфер.
То есть если в очереди на запись стоит заблокированная горутина, ее разблокирует горутина, которая будет читать значение из буфера.

#### Инициализация

```
var nilChan chan int
strChan := make(chan string)
```

```
type hchan struct {
	mx      sync.mutex  
	buffer  []T          // у буферизированных  
	readers []Goroutines // очередь на чтение  
	writers []Goroutines // очередь на запись
}
```

Канал использует `Mutex` -> они работают примерно с одинаковой скоростью.

#### Len & Cap

`Length` - это количество элементов которые в данный момент находятся в буфере канала.
`Capacity` - это размер буфера канала.

`Len & Cap` не буферизированного канала всегда равны 0

```
var nilChan chan int  
intChan := make(chan int)  
intBufChan := make(chan int, 10)  
  
fmt.Printf("len %d, cap %d\n", len(nilChan), cap(nilChan))  
fmt.Printf("len %d, cap %d\n", len(intChan), cap(intChan))  
fmt.Printf("len %d, cap %d\n", len(intBufChan), cap(intBufChan))

// Вывод:
// len 0, cap 0
// len 0, cap 0
// len 0, cap 10
```

#### Запись/чтение из каналa

Для **не буферизированного канала:**
Добавляет горутину в очередь на запись в канал, эта горутина будет **заблокирована**, пока не появиться горутина которая добавиться в очередь на чтение, если такого не произойдет то получиться `deadlock`.

То есть на каждую записывающую горутину должна найтись читающая.

Данные передаются **напрямую** от отправителя к получателю. (у буферизированного они сначала попадают в буфер).
Это значит что данные копируются из **стэкфрейма** одной горутины в **стэкфрэйм** другой.


```
var nilChan chan int
nilChan <- 10 // Запись в пустой канале приводит к Deadlock
```

#### Закрытие канала

Эта операция запрещает запись в канал, но чтение из закрытого канала не запрещено.

```
chan nilChan chan int
close(nilChan) // panic: close of nil channel
```

Вывод: нельзя закрыть nil канал

**\*Закрывать канал надо на том же уровне где происходит запись

Запись в закрытый канал

```
ch := make(chan int)  
close(ch)  
ch <- 1

// panic: send on closed channel
```

Закрытие закрытого канала

```
ch := make(chan int)  
close(ch)  
close(ch)

//panic: close of closed channel
```

Из закрытого канала возможно чтение, и при этом не надо очередь на запись будет пуста, но выводиться будут стандартные значения для этого типа:

```
ch := make(chan int)  
close(ch)  
for true {  
    fmt.Println(<-ch)  
}

// Бесконечный вывод 0
```

\*В буферизированном канале сначала прочитаются все значения из буфера.

Для того чтобы закончить чтение когда закончатся значения можно обрабатывать `bool` переменную возвращаемую методом `<-`.

```
ch := make(chan int)  
close(ch)  

for true {  
    a, er := <-ch  
  
    if !er {  
       fmt.Println(er)  
       break  
    }  
    fmt.Println(a)  
}
```

Или использовать ключевое слово `range`:

```
for a := range ch {
	fmt.Println(a)
}
```

---

#### Буферизированный канал

```
bufChan := make(chan int, 5) // Создает канал с cap = 5
```

Блокировка такого канала зависит от заполнения буфера.

Канал блокируется при чтение если буфер пуст, а также при записи если буфер полный.


#### Направленные каналы

Канал для чтения

```
readChan := make(<-chan int)
```

Канал для записи

```
writeChan := make(chan<- int)
```

Создание таких каналов не имеет смысла, это нужно для того чтобы показать как функция будет работать с каналом, то есть используется в **сигнатурах функций**.

```
func foo(ch <-chan int) {} 
```

В такую функцию можно подать двунаправленный канал, но функция сможет работать с ним только как с однонаправленным


---

## Select

В Go оператор `select` используется для работы с каналами. Он позволяет обрабатывать несколько каналов одновременно, блокируясь до тех пор, пока один из них не станет доступен для чтения или записи.

### Основной синтаксис:

```
select {
case msg1 := <-ch1:
    fmt.Println("Получено из ch1:", msg1)
case msg2 := <-ch2:
    fmt.Println("Получено из ch2:", msg2)
case ch3 <- "Сообщение":
    fmt.Println("Отправлено в ch3")
default:
    fmt.Println("Нет доступных операций, выполняем default")
}
```

### Как это работает:

1. `select` блокируется, пока хотя бы один из каналов не будет готов к операции.
	
2. Если несколько каналов готовы, выбирается один случайным образом.
	
3. `default` выполняется, если ни один канал не доступен (избегая блокировки).


---

### time.After() (timeout)

`time.After(d)` → Возвращает канал, который срабатывает через `d` времени.

Используется для таймаутов, задержек и работы с `select`.

```
select { 
case msg := <-ch: 
	fmt.Println(msg)
	
case <-time.After(2 * time.Second): 
	fmt.Println("Таймаут! Операция заняла слишком много времени.") 
}
```

Если запускается в **цикле** то таймер надо выносить из него:

```
timer := time.After(time.Second) // timer outside the loop

go func() {
	defet close(ch)
	
	for i := 0; i < 1000; i++ {
	
		select {
		case <-timer:
			fmt.Println(time is out)
			return
		default:
			ch <- i
		}
	}
}
```


### time.Tick()

`time.Tick()` - создает канал, который будет посылать сигналы постоянно через заданный промежуток времени.

```
ticker := time.Tick(time.Second) 

count := 0 
for { 
	<-ticker 
	fmt.Println("tick") 
	count++ 
	if count == 3 { 
		break 
	} 
}

//tick
//tick 
//tick
```