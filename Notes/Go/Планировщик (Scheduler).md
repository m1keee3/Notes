### Два типа многозадачности

**1. Кооперативная многозадачность**

Каждая задача выполняется, пока сама не решит передать управление.

**2. Вытесняющая многозадачность**

В этом подходе планировщик сам решает, когда приостановить одну задачу и переключиться на другую, без ее согласия.

### Состояния горутин

Позаимствуем их у тредов.

- **Waiting** — горутина не готова к запуску, так как чего-то ждёт
    
- **Runnable** — готова к запуску, как только освободится тред
    
- **Executing** — выполняется на каком-то треде

![[Pasted image 20250318160631.png]]

Далее нам нужно ввести ещё две сущности:

- **Машина** для выполнения (M, Machine) — будет непосредственно выполнять горутину.
    
- **Процессор** (P, Processor) — будет помещать горутины (G) в Машину.

Не путайте этот Процессор с процессором компьютера или ядрами CPU — названия у них похожие, но суть абсолютно разная

![[Pasted image 20250318160611.png]]


По сути процессор просто привязывает горутину к треду, потому что машина это тот же самый тред.

Про эти же процессоры идет речь в функции `runtime.GOMAXPROCS()`, то есть эта функция ограничивает M (Machine) потому что каждому процессору привязана одна машина.

#### Модель 1 : 1

Это самое простое решение - создавать по одному треду на каждую горутину, **проблема** такой модели заключается в том что создавать треды слишком дорого.

Решением такой проблемы может стать **пул тредов**

#### Пул тредов

Вместо того чтобы пересоздавать треды, можно хранить их в пуле для дальнейшего пере использования 
![[Pasted image 20250318160459.png]]