### Два типа многозадачности

**1. Кооперативная многозадачность**

Каждая задача выполняется, пока сама не решит передать управление.

**2. Вытесняющая многозадачность**

В этом подходе планировщик сам решает, когда приостановить одну задачу и переключиться на другую, без ее согласия.

### Состояния горутин

Позаимствуем их у тредов.

- **Waiting** — горутина не готова к запуску, так как чего-то ждёт
    
- **Runnable** — готова к запуску, как только освободится тред
    
- **Executing** — выполняется на каком-то треде

![[Pasted image 20250318160631.png]]

Далее нам нужно ввести ещё две сущности:

- **Машина** для выполнения (M, Machine) — будет непосредственно выполнять горутину.
    
- **Процессор** (P, Processor) — будет помещать горутины (G) в Машину.

Не путайте этот Процессор с процессором компьютера или ядрами CPU — названия у них похожие, но суть абсолютно разная

![[Pasted image 20250318160611.png]]


По сути процессор просто привязывает горутину к треду, потому что машина это тот же самый тред.

Про эти же процессоры идет речь в функции `runtime.GOMAXPROCS()`, то есть эта функция ограничивает M (Machine) потому что каждому процессору привязана одна машина.

#### Модель 1 : 1

Это самое простое решение - создавать по одному треду на каждую горутину, **проблема** такой модели заключается в том что создавать треды слишком дорого.

Решением такой проблемы может стать **пул тредов**

#### Пул тредов

Вместо того чтобы пересоздавать треды, можно хранить их в пуле для дальнейшего пере использования 
![[Pasted image 20250318160459.png]]

#### Модель M : N 

В такой модели мы ограничиваем количество тредов для того чтобы можно было создавать множество горутин.

1. Мы берем свободные тред из пула, если он есть 
	
2.  Если же его нет то мы проверяем лимит, если можно создать тред то создаем его и подвязываем к нашей горутине
	
3. Если создать треды нельзя то горутина будет ожидать пока какое-то из них освободиться

Так появляется очередь ожидания для горутин - Global Run Queue (GRQ)

![[Pasted image 20250318184026.png]]

Лимит на количество тредов будет количество ядер процессора, иначе какие то из них будут простаивать без дела, меньше создавать стоит только когда горутин будет меньше чем количество логических ядер процессора.

> Таким образом, мы пришли к реальной модели, которая называется M:N Threading. Она заключается в том, что мы выполняем N горутин на M тредах.


#### Mutex для GRQ

С таким подходом возникает проблема, если несколько процессоров одновременно захотят забрать горутину из GRQ. 
Возникает `data race`.

Для его решения как и всегда используется Mutex