
### Состояния горутин

Позаимствуем их у тредов.

- **Waiting** — горутина не готова к запуску, так как чего-то ждёт
    
- **Runnable** — готова к запуску, как только освободится тред
    
- **Executing** — выполняется на каком-то треде

![[Pasted image 20250318160631.png]]

Далее нам нужно ввести ещё две сущности:

- **Машина** для выполнения (M, Machine) — будет непосредственно выполнять горутину.
    
- **Процессор** (P, Processor) — будет помещать горутины (G) в Машину.

Не путайте этот Процессор с процессором компьютера или ядрами CPU — названия у них похожие, но суть абсолютно разная

![[Pasted image 20250318160611.png]]


По сути процессор просто привязывает горутину к треду, потому что машина это тот же самый тред.

Про эти же процессоры идет речь в функции `runtime.GOMAXPROCS()`, то есть эта функция ограничивает M (Machine) потому что каждому процессору привязана одна машина.

#### Модель 1 : 1

Это самое простое решение - создавать по одному треду на каждую горутину, **проблема** такой модели заключается в том что создавать треды слишком дорого.

Решением такой проблемы может стать **пул тредов**

#### Пул тредов

Вместо того чтобы пересоздавать треды, можно хранить их в пуле для дальнейшего пере использования 
![[Pasted image 20250318160459.png]]

#### Модель M : N 

В такой модели мы ограничиваем количество тредов для того чтобы можно было создавать множество горутин.

1. Мы берем свободные тред из пула, если он есть 
	
2.  Если же его нет то мы проверяем лимит, если можно создать тред то создаем его и подвязываем к нашей горутине
	
3. Если создать треды нельзя то горутина будет ожидать пока какое-то из них освободиться

Так появляется очередь ожидания для горутин - Global Run Queue (GRQ)

![[Pasted image 20250318184026.png]]

Лимит на количество тредов будет количество ядер процессора, иначе какие то из них будут простаивать без дела, меньше создавать стоит только когда горутин будет меньше чем количество логических ядер процессора.

> Таким образом, мы пришли к реальной модели, которая называется M:N Threading. Она заключается в том, что мы выполняем N горутин на M тредах.


#### Mutex для GRQ

С таким подходом возникает проблема, если несколько процессоров одновременно захотят забрать горутину из GRQ. 
Возникает `data race`.

Для его решения как и всегда используется Mutex
![[Pasted image 20250318185246.png]]

Вроде бы не плохое решение но проблема здесь заключается в том, что одновременно с GRQ могут захотеть работать множество процессоров, но это будет невозможно, из-за чего наша программа сильно замедляется.

#### Local Run Queue (LRQ)

Чтобы решить эту проблему создадим локальные для каждого процессора очереди - `LRQ`

![[Pasted image 20250318185655.png]]

В получившейся схеме не хватает **waiting горутин**.
На самом деле процессору не приходиться следить за waiting горутинами, этим будут заниматься другие сущности. К примеру, если горутина блокируется из-за записи или чтения из канала, то она попадает в Wait Queue этого канала, и уже оттуда попадает в LRQ и GRQ.

Текущий алгоритм поиска работы (горутины) процессором выглядит так:

1. 1/61 раз проверяем GRQ, и если там есть горутины, то берём оттуда
    
2. Если нет, проверяем LRQ
    
3. Если и там нет, проверяем GRQ

Первый пункт нужен для того чтобы горутины из GRQ не простаивали по долгу.

#### Work stealing

С такой схемой могут появиться простаивающие ядра, если очередь одного из них будет заполнена а у другого пустая.

Можно сделать так чтобы один процессор в случае отсутствия горутин в своей локальной очереди, он будет воровать горутины из LRQ другого процессора.

![[Pasted image 20250318190741.png]]

Таким образом получаем чуть усовершенствованный алгоритм:

1. 1/61 раз проверяем GRQ, и если там есть горутины, то берём оттуда
    
2. Если нет, проверяем LRQ
    
3. Если там нет, пытаемся украсть у другого Процессора
    
4. Если не получилось, проверяем GRQ

### Handoff

Еще одна проблема заключается в том, что горутина может выполнить системный вызов (syscall), в таком случае процессор будет заблокирован, чего хотелось бы избегать.
![[Pasted image 20250318191116.png]]

Получается, что блокируется не только горутина и процессор, но и тред, то есть нам не удастся просто отправить эту ждущую горутину куда-нибудь, придется отправить их вместе - и тред, и горутину.

То есть мы просто создаем новый тред в случае syscall

![[Pasted image 20250318191431.png]]

Этот механизм и называется `handoff`, он помогает с проблемой, но порождает новую, ведь теперь при каждом syscall будет создаваться новый тред, чего хотелось избегать, так как это дорого.

### Sysmon

Некоторые системные вызовы очень короткие, и создавать для них новые треды было бы не рационально.
Можно использовать такую оптимизацию:

- Если мы знаем, что системный вызов заблокирует тред надолго, то мы сразу выполним handoff.
    
- В остальных случаях мы позволим треду какое-то время оставаться в заблокированном состоянии, периодически проверяя, не освободился ли он. Если он превысит некоторый таймаут (а именно, 10ms), то также запускаем handoff

Процесс, который выполняет эти проверки, будет постоянно выполняться в фоне, и называется он - **Sysmon**.
Он выполняется на отдельном треде, так как треды, на которых выполняются горутины могут заснуть, а именно это нам и надо отслеживать.

>К слову, можно сказать, что теперь мы перешли от модели M:N Threading к модели M:P:N Threading. То есть, у нас по прежнему N горутин и M тредов, но также у нас P процессоров. Конечно, сущность процессора мы ввели уже давно, но ранее общее количество используемых тредов и процессоров у нас совпадало, а теперь нет.

### Network Poller

Некоторые системные вызовы способны выполняться асинхронно, в этом помогают механизмы самих операционных систем: `epoll` (Linux), `kqueue` (MacOS, BSD), `IOCP` (Windows)

Теперь можно делать так:

1. Тред инициирует системный вызов и идёт по другим своим делам. Системный вызов будет зарегистрирован в специальной системе, и мы сможем вернуться к нему позже.
    
2. Периодически проверяем, не пришел ли ответ для системного вызова

К сожалению, не все syscall'ы могут выполняться асинхронно, бывает так что приходиться постоянно общаться с системой, например запись или чтение из файла, при таком системном вызове в любом случае будет произведен `handoff`.

Для вызовов, которые все же могут выполняться асинхронно нам понадобится `Network Poller`.
![[Pasted image 20250318195715.png]]

Где и будут находиться горутины ждущие ответа системы.

Итого окончательный алгоритм поиска работы процессором выглядит так:

1. 1/61 раз проверяем GRQ, и если там есть горутины, то берём оттуда
    
2. Если нет, проверяем LRQ
    
3. Если там нет, пытаемся украсть у другого Процессора
    
4. Если не получилось, проверяем GRQ
    
5. Проверяем Network Poller

### Порядок выполнения горутин

При поочередном выполнении горутин может возникнуть ситуация, когда время будет распределяться не равномерно на всех из-за долгой или даже вечной горутины.

Для решения этой проблемы в определенные моменты времени горутина будет проверять не пора ли ей закончить работу:

- **Перед вызовом функций** (пролог): Когда функция вызывается, создаётся фрейм стека (выделенная область в памяти, где хранятся локальные переменные, адрес возврата и другие данные функции). При прерывании в момент вызова функции вся нужная информация уже сохранена во фрейме, поэтому горутину можно приостановить без риска потерять данные. При возобновлении выполнения горутина начнёт с этого вызова функции, используя те же значения переменных.
    
- **При совершении блокирующих операций** (наши любимые syscall'ы, таймеры и прочее): в эти моменты горутина всё равно будет ждать и простаивать, поэтому пусть поработает кто-то другой

Для того чтобы горутина поняла, что ей пора передавать управление планировщику, используется флаг `stackguard`. Когда нам нужно прервать горутину, мы устанавливаем специальное значение `stackPreempt`.

С установкой влага поможет **Sysmon**. Если горутина выполняется дольше определенного времени (10 ms), Sysmon устанавливает флаг `stackguard=stackPreempt`, чтобы при следующей проверке она прервалась.

Такой подход называется кооперативной многозадачностью.

### Два типа многозадачности

**1. Кооперативная многозадачность**

Каждая задача выполняется, пока сама не решит передать управление.

**2. Вытесняющая многозадачность**

В этом подходе планировщик сам решает, когда приостановить одну задачу и переключиться на другую, без ее согласия.

### Вытесняющий подход в Go v1.14

Можно представить следующую ситуацию. Допустим у нас один процессор, и он обрабатывает горутину. Эта горутина что то активно считает и не хочет передавать управление, т. к. не вызывает никакие функции и не делает syscall'ы.

Тогда она заблокирует весь процессор, и Sysmon никак не поможет.
![[Pasted image 20250318202450.png]]

