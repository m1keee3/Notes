## Goroutines

**Горутины** — это **легковесные потоки выполнения**, управляемые runtime Go. Они похожи на потоки (threads) в других языках, но имеют несколько важных отличий:

1. **Легковесность**: Горутины потребляют значительно меньше памяти, чем потоки ОС.

2. **Управление runtime**: Горутины управляются runtime Go, а не операционной системой.

3. **Масштабируемость**: Вы можете запускать тысячи или даже миллионы горутин без значительных накладных расходов.

#### Инициализация

```
func main() {
	go foo() // Запускается в отдельной горутине
}
```

Функция `foo()` может не закончить свое выполнение до того как завершиться главная горутина `main`.

#### Состояние горутин

![[Pasted image 20250227230144.png]]
То есть горутины могут выполняться как в последовательной конкурентности так и параллельно.


---


#### Сколько горутин можно запускать одновременно?

Столько сколько на компе логических ядер:

```
fmt.Print(runtime.NumCPU) // количество логических ядер
```

Также можно выставить максимальное количество выполняемых одновременно горутин:

```
runtime.GOMAXPROCS(n) // n -максимальное количество горутин
```


---

#### Переключение между горутинами вручную

Возможно при помощи использования функции `runtime.Gosched()`

Когда `runtime.Gosched()` вызывается внутри goroutine, Go-рантайм ставит её в очередь на выполнение и переключается на выполнение других доступных goroutine. Однако эта goroutine остаётся активной и снова будет запущена, когда придёт её очередь.


---

### WaitGroup

`sync.WaitGroup` — это структура из пакета `sync`, которая используется для ожидания завершения группы горутин. Она позволяет синхронизировать выполнение программы, блокируя главный поток до тех пор, пока все горутины не завершат свою работу.

**Основные методы:**

- **`Add(int)`** – добавляет количество горутин, которые нужно дождаться.

- **`Done()`** – уменьшает счетчик горутин на 1 (вызывается внутри горутины).

- **`Wait()`** – блокирует выполнение до тех пор, пока счетчик не станет равен 0.

**\*Вызывать метод `Done()` лучше всего через defer (в функции возможно несколько `return` перед каждым из которых придется вызывать метод `Done()`)

```
wg := sync.WaitGroup{}  // Создание переменной WaitGroup
  
for i := 0; i < 10; i++ {  
    wg.Add(1)  // Добавляет горутину которую надо дождаться
  
    go func() {  
	    defer wg.Done()  // говорит о том что одна горутина выполнина
	    fmt.Println(i + 1)  
    }()  
}  
  
wg.Wait() // дожидается выполнения всех горутин
```

Вывод чисел будет в рандомном порядке


---

### Data race

`Data race` - это множественное обращение к одним и тем же данным из разных горутин, где хотя бы одно из этих обращений запись

Рассмотрим две программы:

Выполнение функции в одной горутине
```
start := time.Now()  
ctr := 0  
  
for i := 0; i < 1000; i++ {  
    func() {  
       ctr++  
       time.Sleep(time.Nanosecond)  
    }()  
}  
  
fmt.Println(ctr)                             // 1000
fmt.Println(time.Now().Sub(start).Seconds()) // 0.5157675
```

Выполнение функции в нескольких горутинах
``` 
wg := sync.WaitGroup{}  
start := time.Now()  
ctr := 0  

wg.Add(1000)  

for i := 0; i < 1000; i++ {  
   go func() {  
	  defer wg.Done()  
	  ctr++  
	  time.Sleep(time.Nanosecond)  
   }()  
}  
wg.Wait()  

fmt.Println(ctr)                             // 980  
fmt.Println(time.Now().Sub(start).Seconds()) // 0.0026929  

```

Это своего рода UB поскольку горутины не знают друг о друге и могут выполнять одни и те же операции как в данном случае инкремент


---

### Mutex

`sync.Mutex` - это механизм, который предотвращает одновременный доступ нескольких горутин к общему ресурсу. Он используется для защиты критических секций кода, где возможны `data race`.

`Lock()` - вызывая этот метод горутина пытается захватить мьютекс, если он уже захвачен другой горутиной, то текущая **блокируется** и ждет, пока мьютекс будет освобожден.
Если ей удалось захватить мьютекс то другие горутины вызывающие метод `Lock()` будут ждать, пока текущая не вызовет метод `Unlock()`

```
wg := sync.WaitGroup{}  
start := time.Now()  
ctr := 0  
m := sync.Mutex{}  
  
wg.Add(1000)  
  
for i := 0; i < 1000; i++ {  
    go func() {  
       defer wg.Done()  
       m.Lock()  
       ctr++  
       m.Unlock()  
       time.Sleep(time.Nanosecond)  
    }()  
}  
wg.Wait()  
  
fmt.Println(ctr)                             // 1000  
fmt.Println(time.Now().Sub(start).Seconds()) // 0.0025548
```


### RWMutex

`RWMutex` - позволяет эффективно управлять доступом к общим ресурсам в сценариях с частым чтением и редкой записью.

`RLock` - Разрешает читать множеству потоков, но запрещает запись

```
for i := 0; i < 1000; i++ {  
    go func() {  
       defer wg.Done()  
       rm.Lock()  
       ctr++  
       rm.Unlock()  
    }()  
    go func() {  
       defer wg.Done()  
       rm.RLock()  // Блокировка для записи
       _ = ctr  
       rm.RUnlock()  
    }()  
}
```

#### Когда использовать?

- **Оптимально**: Частые чтения, редкие записи (например, кэши, конфигурации).

- **Не оптимально**: Если записи происходят часто — обычный `Mutex` может быть эффективнее, так как `RWMutex` сложнее и имеет накладные расходы.

#### Осторожно!

- **Deadlocks**: Всегда используйте `defer` для разблокировки, чтобы избежать забытых `Unlock`.

- **Копирование**: Не копируйте `RWMutex` после использования (передавайте по указателю).

- **Приоритет записи**: Длительные операции чтения могут блокировать запись — проектируйте логику аккуратно.


---

### Deadlock

`Deadlock` - то ситуация, когда две или более горутины не могут продолжить выполнение, потому что каждая из них ожидает освобождения ресурса, занятого другой.

##### Условия возникновения deadlock

1. **Взаимное исключение** (Mutual Exclusion): Ресурс может быть занят только одной горутиной.
    
2. **Удержание и ожидание** (Hold and Wait): Горутина удерживает один ресурс и ждет другой.
    
3. **Нет вытеснения** (No Preemption): Ресурс нельзя отобрать у горутины.
    
4. **Кольцевое ожидание** (Circular Wait): Горутины образуют кольцо, где каждая ждет ресурс от следующей.

#### Примеры deadlock

##### 1. Deadlock с каналами

**Ситуация**: Нет получателя для канала.

```
func main() {
    ch := make(chan int)
    ch <- 42       // Отправка в канал (main-горутина блокируется)
    fmt.Println(<-ch) // Сюда выполнение не дойдет
}
```


##### 2. Взаимная блокировка с мьютексами

**Ситуация**: Два мьютекса захватываются в разном порядке.

```
var mu1, mu2 sync.Mutex

func goroutine1() {
    mu1.Lock()
    defer mu1.Unlock()
    time.Sleep(1 * time.Second) // Имитация работы
    mu2.Lock()                  // Ждет mu2, который удерживается goroutine2
    defer mu2.Unlock()
}

func goroutine2() {
    mu2.Lock()
    defer mu2.Unlock()
    time.Sleep(1 * time.Second)
    mu1.Lock()                  // Ждет mu1, который удерживается goroutine1
    defer mu1.Unlock()
}

func main() {
    go goroutine1()
    go goroutine2()
    time.Sleep(5 * time.Second) // Ждем завершения (но его не будет)
}
```

##### 3. Все горутины уснули

```
func main() {
    ch := make(chan int)
    <-ch // Главная горутина ждет данные, но их никто не отправит
}
```


---


## Pipeline

- **Производитель (Producer)** отправляет данные в первый канал.
- **Этапы обработки (Stages)** работают в отдельных горутинах и передают данные дальше.
- **Потребитель (Consumer)** получает обработанные данные из последнего канала.

Между каждым обработчиком создается свой **канал**

\*Не забывать добавить **Waitgroup**


---


## Worker pool

#### Как работает Worker Pool?

1. **Очередь задач**: создается канал (`jobs`), в который отправляются задачи.
2. **Пул воркеров**: запускается фиксированное количество горутин (воркеров), которые слушают этот канал и выполняют задачи.
3. **Канал результатов** (необязательно): можно использовать дополнительный канал (`results`) для передачи результатов выполнения.

#### Пример реализации

```
// Worker - обрабатывает задачи из канала jobs и отправляет результаты в results
func worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {

	defer wg.Done()
	for job := range jobs {
	
		results <- job * 2 // Отправка результата
	}
}

func main() {

	numWorkers := 3   // Количество воркеров
	numJobs := 10     // Количество задач

	jobs := make(chan int, numJobs)
	results := make(chan int, numJobs)
	var wg sync.WaitGroup

	// Запускаем воркеров
	for i := 1; i <= numWorkers; i++ {
		wg.Add(1)
		go worker(i, jobs, results, &wg)
	}

	// Отправляем задачи
	for j := 1; j <= numJobs; j++ {
		jobs <- j
	}
	close(jobs) // Закрываем канал, чтобы воркеры знали, что задач больше не будет

	// Ждем завершения всех воркеров в отдольное горутине
	go func() {
		wg.Wait()
		close(results)
	}()
	
	for result := range results {
		fmt.Println("Result:", result)
	}
}

```