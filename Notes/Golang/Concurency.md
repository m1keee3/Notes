## Goroutines

**Горутины** — это **легковесные потоки выполнения**, управляемые runtime Go. Они похожи на потоки (threads) в других языках, но имеют несколько важных отличий:

1. **Легковесность**: Горутины потребляют значительно меньше памяти, чем потоки ОС.

2. **Управление runtime**: Горутины управляются runtime Go, а не операционной системой.

3. **Масштабируемость**: Вы можете запускать тысячи или даже миллионы горутин без значительных накладных расходов.

#### Инициализация

```
func main() {
	go foo() // Запускается в отдельной горутине
}
```

Функция `foo()` может не закончить свое выполнение до того как завершиться главная горутина `main`.

#### Состояние горутин

![[Pasted image 20250227230144.png]]
То есть горутины могут выполняться как в последовательной конкурентности так и параллельно.


---


#### Сколько горутин можно запускать одновременно?

Столько сколько на компе логических ядер:

```
fmt.Print(runtime.NumCPU) // количество логических ядер
```

Также можно выставить максимальное количество выполняемых одновременно горутин:

```
runtime.GOMAXPROCS(n) // n -максимальное количество горутин
```


---

#### Переключение между горутинами вручную

Возможно при помощи использования функции `runtime.Gosched()`

Когда `runtime.Gosched()` вызывается внутри goroutine, Go-рантайм ставит её в очередь на выполнение и переключается на выполнение других доступных goroutine. Однако эта goroutine остаётся активной и снова будет запущена, когда придёт её очередь.


---

### WaitGroup

`sync.WaitGroup` — это структура из пакета `sync`, которая используется для ожидания завершения группы горутин. Она позволяет синхронизировать выполнение программы, блокируя главный поток до тех пор, пока все горутины не завершат свою работу.

**Основные методы:**

- **`Add(int)`** – добавляет количество горутин, которые нужно дождаться.

- **`Done()`** – уменьшает счетчик горутин на 1 (вызывается внутри горутины).

- **`Wait()`** – блокирует выполнение до тех пор, пока счетчик не станет равен 0.

**\*Вызывать метод `Done()` лучше всего через defer (в функции возможно несколько `return` перед каждым из которых придется вызывать метод `Done()`)

```
wg := sync.WaitGroup{}  // Создание переменной WaitGroup
  
for i := 0; i < 10; i++ {  
    wg.Add(1)  // Добавляет горутину которую надо дождаться
  
    go func() {  
	    defer wg.Done()  // говорит о том что одна горутина выполнина
	    fmt.Println(i + 1)  
    }()  
}  
  
wg.Wait() // дожидается выполнения всех горутин
```

Вывод чисел будет в рандомном порядке

## Каналы (Channels)

## Планировщик (Scheduler)