Замыкание — это функции, которые **запоминают и используют переменные из внешней области видимости** даже после завершения выполнения этой области.

В Go можно объявлять **анонимные функции** и присваивать их переменной. Если такая функция использует переменные из внешней функции, она **создаёт замыкание**, сохраняя доступ к этим переменным.

**Пример:**

```
func main() {  
    a1 := foo()
    a2 := foo()
    fmt.Println(a1())  // 1
    fmt.Println(a1())  // 2
    fmt.Println(a2())  // 1
    fmt.Println(a2())  // 2
}  
  
func foo() func() int {  
    x := 0  
    return func() int {  
       x++  
       return x  
    }  
}
```

В данном примере используя **escape analysis** Go каждый раз перемещает `x` со стека на кучу.
При каждом новом вызове foo() на куче создается новая переменная `x`.

**\*Замыкания захватывают переменные по ссылке а не копируют их**

```
funcs := []func(){}

for i := 0; i < 3; i++ {
	funcs = append(funcs, func() { fmt.Print(i) })
}

for _, f := range funcs {
	f()
}

// Вывод
// 3 3 3 в версиях до 1.22
```

так происходит потому что замыкания захватили ссылку на `i` и к моменту их вызова `i = 3`, однако с версии 1.22 на внутри скоупа оператора создается новая локальная переменная i благодаря чему вывод будет 0 1 2.

Для того чтобы исправить можно передавать `i` в качестве аргумента в анонимную функцию или создать копию `i`:

```
funcs := []func(){}

for i := 0; i < 3; i++ {
	i := i
	funcs = append(funcs, func() { fmt.Print(i) })
}

for _, f := range funcs {
	f()
}

// Вывод
// 0 1 2
```

В Go можно объявлять переменную с тем же именем в более узком scope 