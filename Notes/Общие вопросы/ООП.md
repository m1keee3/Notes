## 1. Введение

**ООП (Object-Oriented Programming)** — это парадигма программирования, в основе которой лежит понятие объекта, как некоторой структуры, описывающей объект реального мира, его поведение.
Объект = данные (состояние) + методы (поведение).

Преимущества ООП:

- Естественное моделирование реального мира.
    
- Повторное использование кода.
    
- Масштабируемость и поддерживаемость.
    
- Гибкость архитектуры.

---

## 2. Четыре принципа ООП

### 1. Абстракция

- Сокрытие деталей реализации и работа только с необходимыми характеристиками объекта.
    
- Пример: класс `Car` имеет методы `drive()`, `stop()`, но мы не обязаны знать, как работает двигатель.

### 2. Инкапсуляция

- Объединение данных и методов, которые с ними работают, внутри одного объекта.
    
- Ограничение доступа (public, private, protected).
    
- Пример: переменные объекта доступны только через методы (геттеры/сеттеры).

### 3. Наследование

- Возможность создавать новые классы на основе существующих.
    
- Упрощает повторное использование кода.
    
- Пример: `class Dog extends Animal`.

### 4. Полиморфизм

- Возможность использовать один интерфейс для разных реализаций.
    
- Разные объекты могут по-своему реализовать один и тот же метод.
    
- Пример: метод `makeSound()` у `Dog` и `Cat` работает по-разному.

---

## 3. SOLID-принципы

**SOLID** — набор принципов для построения гибкой и поддерживаемой архитектуры.

1. **S — Single Responsibility Principle (Принцип единственной ответственности)**
    
    - Класс должен иметь только одну причину для изменения.
        
2. **O — Open/Closed Principle (Принцип открытости/закрытости)**
    
    - Классы должны быть открыты для расширения, но закрыты для модификации.
  
Пример не соблюдения ❌
```go
type DiscountCalculator struct{}  
  
func (d *DiscountCalculator) CalculateDiscount(userType UserType, price float64) float64 {  
    switch userType {  
    case "regular":  
       return price  
    case "vip":  
       return price * 0.8  
    }  
    return 0  
}
``` 

Чтобы исправить можно ввести интерфейс, тогда не надо будет менять код, а можно будет просто добавлять реализации

```

```
1. **L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)**
    
    - Объекты дочерних классов должны корректно заменять объекты базовых классов.
        
2. **I — Interface Segregation Principle (Принцип разделения интерфейсов)**
    
    - Лучше несколько специализированных интерфейсов, чем один «толстый».
        
3. **D — Dependency Inversion Principle (Принцип инверсии зависимостей)**
    
    - Модули должны зависеть от абстракций, а не от конкретных реализаций.

---

## 4. GRASP-паттерны

**GRASP (General Responsibility Assignment Software Patterns)** — принципы распределения обязанностей между классами.



---

## 5. Дополнительные концепции ООП

### Композиция vs Наследование

- **Наследование** — «is-a» (собака — это животное).
    
- **Композиция** — «has-a» (машина имеет двигатель).
    
- Композиция предпочтительнее при проектировании гибких систем.

### Паттерны проектирования

- Порождающие: Singleton, Factory, Builder.
    
- Структурные: Adapter, Decorator, Proxy.
    
- Поведенческие: Strategy, Observer, Command.

---

## 6. Преимущества и недостатки ООП

### Преимущества:

- Код ближе к реальному миру.
    
- Повторное использование кода.
    
- Поддерживаемость и модульность.
    
- Гибкая архитектура.

### Недостатки:

- Более высокая сложность по сравнению с процедурным программированием.
    
- Накладные расходы на абстракции.
    
- Иногда излишнее использование наследования ведёт к «хрупкой архитектуре».