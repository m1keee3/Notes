## 1. Введение

**ООП (Object-Oriented Programming)** — это парадигма программирования, в которой объектам реального мира соответствуют программные .  
Объект = данные (состояние) + методы (поведение).

Преимущества ООП:

- Естественное моделирование реального мира.
    
- Повторное использование кода.
    
- Масштабируемость и поддерживаемость.
    
- Гибкость архитектуры.
    

---

## 2. Четыре принципа ООП

### 1. Абстракция

- Сокрытие деталей реализации и работа только с необходимыми характеристиками объекта.
    
- Пример: класс `Car` имеет методы `drive()`, `stop()`, но мы не обязаны знать, как работает двигатель.
    

### 2. Инкапсуляция

- Объединение данных и методов, которые с ними работают, внутри одного объекта.
    
- Ограничение доступа (public, private, protected).
    
- Пример: переменные объекта доступны только через методы (геттеры/сеттеры).
    

### 3. Наследование

- Возможность создавать новые классы на основе существующих.
    
- Упрощает повторное использование кода.
    
- Пример: `class Dog extends Animal`.
    

### 4. Полиморфизм

- Возможность использовать один интерфейс для разных реализаций.
    
- Разные объекты могут по-своему реализовать один и тот же метод.
    
- Пример: метод `makeSound()` у `Dog` и `Cat` работает по-разному.
    

---

## 3. SOLID-принципы

**SOLID** — набор принципов для построения гибкой и поддерживаемой архитектуры.

1. **S — Single Responsibility Principle (Принцип единственной ответственности)**
    
    - Класс должен иметь только одну причину для изменения.
        
2. **O — Open/Closed Principle (Принцип открытости/закрытости)**
    
    - Классы должны быть открыты для расширения, но закрыты для модификации.
        
3. **L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)**
    
    - Объекты дочерних классов должны корректно заменять объекты базовых классов.
        
4. **I — Interface Segregation Principle (Принцип разделения интерфейсов)**
    
    - Лучше несколько специализированных интерфейсов, чем один «толстый».
        
5. **D — Dependency Inversion Principle (Принцип инверсии зависимостей)**
    
    - Модули должны зависеть от абстракций, а не от конкретных реализаций.
        

---

## 4. GRASP-паттерны

**GRASP (General Responsibility Assignment Software Patterns)** — принципы распределения обязанностей между классами.

Основные:

1. **Information Expert** — назначаем ответственность тому, кто владеет нужными данными.
    
2. **Creator** — класс, который использует другой объект, должен создавать его.
    
3. **Controller** — выделяем класс для обработки входных событий.
    
4. **Low Coupling** — низкая связанность: объекты должны минимально зависеть друг от друга.
    
5. **High Cohesion** — высокая связность: класс выполняет ограниченный набор логически связанных функций.
    
6. **Polymorphism** — используем полиморфизм для обработки вариаций поведения.
    
7. **Pure Fabrication** — создаём вспомогательный класс, если это улучшает архитектуру.
    
8. **Indirection** — посредник для снижения связности между компонентами.
    
9. **Protected Variations** — изолируем изменяющиеся части системы за счёт абстракций.
    

---

## 5. Дополнительные концепции ООП

### Композиция vs Наследование

- **Наследование** — «is-a» (собака — это животное).
    
- **Композиция** — «has-a» (машина имеет двигатель).
    
- Композиция предпочтительнее при проектировании гибких систем.
    

### Паттерны проектирования

- Порождающие: Singleton, Factory, Builder.
    
- Структурные: Adapter, Decorator, Proxy.
    
- Поведенческие: Strategy, Observer, Command.
    

---

## 6. Преимущества и недостатки ООП

### Преимущества:

- Код ближе к реальному миру.
    
- Повторное использование кода.
    
- Поддерживаемость и модульность.
    
- Гибкая архитектура.
    

### Недостатки:

- Более высокая сложность по сравнению с процедурным программированием.
    
- Накладные расходы на абстракции.
    
- Иногда излишнее использование наследования ведёт к «хрупкой архитектуре».

