### Синтаксис `SELECT`

Рассмотрим запрос выборки в SQL - его можно разделить на 5 частей:

1. **Выбор столбцов отношения**:
    
```
 SELECT [ DISTINCT | ALL ] { * | [ColumnExpression [AS NewName] ] [, ...]}
```
    
Ключевое слово `DISTINCT` определяет выбор только уникальных кортежей, `ALL` - явный выбор кортежей с дубликатами
	
Далее указываются имена столбцов (также возможны их алиасы) или `*`, которая определяет вывод всех столбцов отношения
    
2. **Выбор исходного отношения**:
    
```
 FROM TableName [AS NewTableName] 
 [{INNER | LEFT OUTER | FULL} JOIN OuterTable [AS NewOuterTableName] 
 ON Condition]
```
    
Здесь же можно определить соединение и его тип на основе условия `Condition`
    
3. **Фильтрация кортежей**:
    
```
 [WHERE Condition]
```
    
В инструкции `WHERE` определяются условия для фильтрации кортежей
    
4. **Группировка**:
    
```
 [GROUP BY ColumnList [, ...] [HAVING Condition]]
```
    
В инструкции `GROUP BY` производится группировка по указанному набору атрибутов и фильтрации через условие в `HAVING`
    
5. **Сортировка**:
    
```
 [ORDER BY ColumnList [, ...] [{ASC | DESC}]]
```
    
И, наконец, в инструкции `ORDER BY` происходит сортировка конечного отношения по указанному набору атрибутов
    

В конечном счете, получаем:

```
SELECT [ DISTINCT | ALL ] { * | [ColumnExpression [AS NewName] ] [, ...]}
FROM TableName [AS NewTableName] 
[{INNER | LEFT OUTER | FULL} JOIN OuterTable [AS NewOuterTableName] 
ON Condition]
[WHERE Condition]
[GROUP BY ColumnList [, ...] [HAVING Condition]]
[ORDER BY ColumnList [, ...] [{ASC | DESC}]]
```

Здесь стоит заметить, что желательно общие условия, которые имеют место в инструкции `WHERE` стоит размещать именно там, а не в `HAVING`, так как фильтрация кортежей после группировки работает медленнее и не обеспечивает производительность

Порядок выполнения инструкций в `SELECT` запросе таков:

1. `FROM`
2. `ON`
3. `JOIN`
4. `WHERE`
5. `GROUP BY`
6. `HAVING`
7. `SELECT`
8. `DISTINCT`
9. `ORDER BY`

---
## Join

1. `INNER JOIN` 
	
	**Что делает:** Возвращает **только те записи**, для которых есть совпадение в **обеих** таблицах.
	
2. `LEFT JOIN`
	
	**Что делает:** Возвращает **ВСЕ записи из левой** таблицы, и **совпадающие** записи из правой таблицы. Если совпадений нет, то поля из правой таблицы будут заполнены `NULL`.
	
3. `RIGHT JOIN`
	
	**Что делает:** Полная противоположность `LEFT JOIN`. Возвращает **ВСЕ записи из правой** таблицы, и **совпадающие** записи из левой таблицы. Если совпадений нет, то поля из левой таблицы будут заполнены `NULL`.
	
2. `FULL JOIN`
	
	**Что делает:** Возвращает **все записи из обеих таблиц**. Если для записи из одной таблицы нет совпадения в другой, недостающие поля заполняются `NULL`.


Соединение можно делать:

- Вложенными циклам (Nested Loop) - хорошо подходит для небольших таблиц или при наличии индексов
    
- Сортировкой и слиянием (Merge Join) - алгоритм эффективен при предварительной сортировке
    
- Хеш-соединение (Hash Join) - быстрое, используется хеш-таблица с цепочками
    
- Параллельное хеш-соединение - для ускорения на многоядерных системах
    

PostgreSQL использует быструю сортировку (quicksort), чтобы выполнить операцию соединения. Размер выделенной памяти для сортировки контролируется параметром `work_mem`. Если объем данных превышает `work_mem`, PostgreSQL может производить сортировку с временным сохранением промежуточных результатов на диске