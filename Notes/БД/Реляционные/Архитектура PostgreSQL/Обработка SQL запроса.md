1. **Лексический анализ**
    
    На этом этапе сервер принимает SQL-текст запроса и анализирует его на наличие синтакcических ошибок. Результатом является дерево разбора (parse tree), представляющее структуру запроса
    
1. **Семантический разбор**
    
    Здесь заменяются представления на их определения, обрабатываются правила, определенные для таблиц, а так же проверяются права у пользователя к этим объектам
    
1. **Планирование**
    
    PostgreSQL может выполнять один и тот же запрос разными способами. Планировщик генерирует альтернативные планы (деревья с физическими операциями)
    
    Планировщик принимает переписанное дерево запроса и генерирует один или несколько вариантов выполнения запроса. Количество возможных планов экспоненциально зависит от количества соединяемых таблиц. Для сокращения пространства перебора традиционно используется алгоритм динамического программирования с эвристиками
    
    С помощью ключевого слова `EXPLAIN` можно узнать структуру плана запроса, а с помощью `EXPLAIN ANALYZE` можно, выполнив его, узнать реальные затраты
    
    Оптимизатор оценивает стоимость каждого варианта плана, используя статистические данные о таблицах. Точное решение задачи оптимизации не гарантирует, что найденный план будет действительно лучшим
    
    Планы делятся на _общие_ и _частные_. При выполнении подготовленных запросов план выполнения может быть сохранен и повторно использован
    
    Общий план, который строится один раз без учета конкретных значений параметров, предоставленных во время исполнения
    
    Частный план, который создается при каждом выполнении подготовленного запроса и учитывает конкретные значения параметров
    
    Если запрос, выполненный по частному плану, поступает многократно, то частный план становится общим. Однако, если время ответа увеличилось, то он обратно становится частным
    
1. **Выполнение**
    
    После выбора оптимального плана исполнитель запускает последовательность операций, предусмотренных планом. Он последовательно проходит по узлам плана
    
    При выполнении запросов осуществляется доступ к данным через буферный менеджер, который минимизирует количество операций ввода/вывода на диск
    
    Если запрос рассчитан на параллельное выполнение, результат собирается из нескольких рабочих процессов
