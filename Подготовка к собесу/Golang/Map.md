##### Инициализация
```
1. m := map[string]int
2. m := make(map[string]int)
```

#### Что из себя представляет 

**Операции выполняются за O(1)**
Использует хэширование

```
type hmap struct {
    count     int    // количество элементов
    B         uint8  // log2(количество бакетов)
    buckets   unsafe.Pointer // указатель на массив бакетов
    extra     *mapextra // overflow-данные
    hash      uint32 // Используется для крипто устойчивости мапы
}
```

Для того чтобы понимать с каким типом мы работаем используется type discriptor

---

##### Type descriptor
Хранит всю мета информацию о типе
Предоставляет операции hash, equal, copy
```
type _type struct {
	size uintptr
	equal func(unsafe.Pointer, unsafe.Pointer)bool
	hash func(unsafe.Pointer, uintptr)uintptr
}
```

#### Map type
Хранит в себе информацию о значениях с которыми он работает (type discriptor)
```
type mapType struct {
	key *_type
	value *_type
	...
}
```

---

#### Коллизии
Происходят когда двух разных ключей совпадает хэш

Для решения используется:
1. HOB (high order bits) (ускоренный поиск)
2. Использование overflow бакетов
3. Эвакуация данных grow()

Map в Golang использует гибридную адресацию:
- Основные данные хранятся в массиве бакетов (похоже на открытую адресацию).
- Если бакет переполняется (в нём уже 8 элементов), создаётся overflow-бакет.
- Overflow-бакеты связаны между собой (похоже на закрытую адресацию, на связные списки).


#### Хэширование

Хэш функция должна обладать следующими свойствами:

1. Равномерность
2. Быстрота (O)1
3. Детерминированность (один и тот же хеш для одинаковых ключей)
4. Крипто устойчивость (тяжело подобрать ключи таким образом что все ключи попадут в один бакет)

---

#### Buckets

Количество бакетов в map всегда степень двойки
Хранит максимум 8 элементов

```
type bucket struct {
    tophash [8]uint8  // High order bits для ускоренного поиска
    keys    [8]K      // Ключи
    values  [8]V      // Значения
    overflow *bucket  // Указатель на следующий бакет (если переполнен)
}

tophash: [0x8F, 0x72, 0x00, 0x9A, 0x00, 0x5C, 0x00, 0x34]
```

tophash - HOB используется для быстрого поиска


#### LOB и HOB

**LOB** (low order bits) - это первые B (log от числа бакетов) биты числа 
Используются для определения индекса бакета

**HOB** (high order bits) - это оставшиеся старшие биты
Используются для быстрого поиска по бакету

Узнаем почему храниться именно log количества бакетов:

Представим что количество бакетов 8, тогда B = 3

1. Число бакетов
```
num_backets := 1 << hmap.B
```
2. Быстрое вычисление индекса бакета
```
bucket_index = hash & (num_buckets - 1)
```

num_backets = $1000_2$
hash = $101110_2$

тогда данная операция *bucket_index = hash & (num_buckets - 1)* позволит вычислить последние B битов числа:

num_backets - 1 = $0111_2$
hash & (num_buckets - 1) = $101110_2$ & $0111_2$ = $000110_2$

---

##### Поиск 
Сначала проходиться по LOB находит backet, затем проходиться по HOB чтобы найти совпадение

В среднем работает за (O)1 но при большом количестве коллизий приближается к (O)n  

#### Расширение map