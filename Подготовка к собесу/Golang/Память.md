
### Виртуальная память

Это технология управления памятью, используемая ОС для предоставления программам иллюзии наличия большого, непрерывного адресного пространства, даже если физическая память (RAM) ограничена. Виртуальная память также обеспечивает изоляцию процессов, защиту памяти и эффективное использование ресурсов.

### Основные концепции виртуальной памяти

1. **Адресное пространство**:
    
    - Каждая программа работает в своем собственном **виртуальном адресном пространстве**, которое не зависит от других программ и физической памяти.
        
    - Виртуальные адреса преобразуются в физические адреса с помощью аппаратной поддержки (MMU — Memory Management Unit).
        
2. **Страницы (Pages)**:
    
    - Виртуальная память делится на блоки фиксированного размера, называемые **страницами** (обычно 4 КБ на x86/x64 архитектурах).
        
    - Физическая память также делится на страницы того же размера.
        
3. **Таблица страниц (Page Table)**:
    
    - Таблица страниц — это структура данных, которая хранит соответствие между виртуальными и физическими адресами.
        
    - Каждая запись в таблице страниц (Page Table Entry, PTE) содержит информацию о том, где находится соответствующая страница в физической памяти или на диске.
        
4. **Подкачка (Swapping)**:
    
    - Если физической памяти не хватает, операционная система может переместить неиспользуемые страницы на диск (в **файл подкачки** или **swap-раздел**) и освободить физическую память для других задач.
        
    - Когда программа пытается получить доступ к странице, которая находится на диске, происходит **page fault** (ошибка страницы), и операционная система загружает страницу обратно в память.
        
5. **Фрагментация**:
    
    - Виртуальная память позволяет программам использовать непрерывное адресное пространство, даже если физическая память фрагментирована.


---

### Stack

По идеи все переменные созданные не через make или new выделяются на стэке, на самом деле не всегда

Рассмотри такую проблему:

```
func main() {
	x := getValue()
	Println(*x)
}

func getValue() *int {
	x := 4
	return &x
}
```

Вызов функции Println затрет stack frame с x и мы получим проблему **Dangling Pointer**
В Go такая проблема решается путем выделения x на heap

Переменная будет выделена на heap а не на stack если:
1. Результат возвращается по ссылке
2. Значение передается в аргумент типа interface{}
3. Размер значения переменной превышает лимиты стека

### Heap
### Фрагментация
### GC (garbage collector)

Использует алгоритм **mark & sweep**
